syntax = "proto3";

import "google/api/annotations.proto";

option go_package = "github.com/jamespfennell/transiter/api";

/**
Admin API
*/
service Admin {
  // Get the config for a system
  //
  // `GET /systems/<system_id>/config`
  rpc GetSystemConfig(GetSystemConfigRequest) returns (SystemConfig) {
    option (google.api.http) = {
      get: "/systems/{system_id}/config"
    };
  }

  // Install or update a system
  //
  // `PUT /systems/<system_id>`
  //
  // Installs or updates the system based on the configuration provided in the
  // request payload.
  // If the system does not exist an install is performed; otherwise an update.
  rpc InstallOrUpdateSystem(InstallOrUpdateSystemRequest) returns (InstallOrUpdateSystemReply) {
    option (google.api.http) = {
      put: "/systems/{system_id}"
      body: "*"
    };
  }

  // Delete a system
  //
  // `DELETE /systems/<system_id>`
  //
  // Deletes the specified system.
  rpc DeleteSystem(DeleteSystemRequest) returns (DeleteSystemReply) {
    option (google.api.http) = {
      delete: "/systems/{system_id}"
    };
  }

  // Update a feed
  //
  // `POST /systems/<system_id>/feeds/<feed_id>`
  //
  // Triggers a feed update for the specified feed.
  rpc UpdateFeed(UpdateFeedRequest) returns (UpdateFeedReply) {
    option (google.api.http) = {
      post: "/systems/{system_id}/feeds/{feed_id}"
    };
  }

  // Get scheduler status
  //
  // `GET /scheduler`
  //
  // Gets the status of the scheduler.
  rpc GetSchedulerStatus(GetSchedulerStatusRequest) returns (GetSchedulerStatusReply) {
    option (google.api.http) = {
      get: "/scheduler"
    };
  }

  // Reset scheduler
  //
  // `POST /scheduler`
  //
  // Performs a full restart of the scheduler, with all scheduler
  //   configurations retrieved fresh from the database.
  // In general this endpoint should never be needed;
  //   Transiter automatically restarts the scheduler when needed.
  //  The main usecase is when the Postgres configuration is manually
  //   updated and the scheduler needs to see the update.
  rpc ResetScheduler(ResetSchedulerRequest) returns (ResetSchedulerReply) {
    option (google.api.http) = {
      post: "/scheduler"
    };
  }

  // Garbage collect feed updates
  //
  // `POST /gcfeedupdates`
  //
  // Deletes feed updates that are older than a week, with the exception that
  // the most recent succesful update for each feed is always retained.
  //
  // This method exists to avoid unbounded growth in the feed updates database table.
  // It is called periodically by the scheduler.
  rpc GarbageCollectFeedUpdates(GarbageCollectFeedUpdatesRequest) returns (GarbageCollectFeedUpdatesReply) {
    option (google.api.http) = {
      post: "/gcfeedupdates"
    };
  }

  // TODO: GetFeedConfig
}

message GetSystemConfigRequest {
  string system_id = 1;
}

message InstallOrUpdateSystemRequest {
  // ID of the system to install or update.
  string system_id = 1;

  oneof config {
    SystemConfig system_config = 2;
    TextConfig yaml_config = 3;
    // TODO: TextConfig json_config = 4;
  }

  // If true, do not perform an update if the system already exists.
  // TODO: rename skip_update = 4; ?
  bool install_only = 4;

  // If false (the default), the system configuration is validated before the request finishes
  // but databse updates are performed asynchronously. The status of the operation can
  // be polled using GetSystem and inspecting the status field.
  //
  // If true, the install/update operation is perfomed synchronously in the
  // request and in a single database transaction.
  // In this case, if the operation fails there will no database artifacts.
  // The problem
  // is that installs can take a long time and the request may be cancelled before it completes
  // e.g. by an intermediate proxy.
  bool synchronous = 5;
}

// TextConfig contains a Transiter system configuration in non-proto format
// (e.g. YAML or JSON).
message TextConfig {
  oneof source {
    // A URL where the config can be retrieved from using a simple GET request.
    // If the URL requires a more complex interaction (authentication, a different
    // HTTP verb), the config should be retrieved outside of Transiter and provided
    // in the content field.
    string url = 1;
    // The text content of the config.
    string content = 2;
  }
  // Whether the config is a template. If true the config will first be processed
  // using Go's template library.
  bool is_template = 3;

  // Arguments to pass to Go's template library if the config is a template.
  //
  // In general as much information as possible should be in the config itself.
  // The template args are intended for things like API keys which are secret
  // and/or different for each person that installs the system.
  map<string, string> template_args = 4;
}

message InstallOrUpdateSystemReply {
  string system_id = 1;
  SystemConfig system_config = 2;
}

message DeleteSystemRequest {
  string system_id = 1;
}

message DeleteSystemReply {}

// Configuration for a system.
message SystemConfig {
  // Name of the system.
  string name = 1;
  // Configuration for the system's feeds.
  repeated FeedConfig feeds = 2;
  // Configuration for the system's service maps.
  repeated ServiceMapConfig service_maps = 3;
}

message FeedConfig {
  // Identifier of this feed config.
  // This must be unique within the system.
  string id = 1;

  // If true, an update of this feed will be performed during the system installation,
  // and if the update fails the system installation will fail.
  bool required_for_install = 2;

  enum UpdateStrategy {
    NONE = 0;
    PERIODIC = 1;
  }
  UpdateStrategy update_strategy = 3;

  optional double update_period_s = 4;

  // URL at which the feed can be downloaded using a HTTP GET request.
  // Transiter does not currently support non-GET requests.
  string url = 5;
  // Timeout to enforce for the request to the feed URL. If not specified, defaults to 5 seconds.
  optional int64 request_timeout_ms = 6;
  // HTTP headers to send in the request.
  map<string, string> http_headers = 7;

  // The parser to parse the feed with. Current options are "GTFS_STATIC",
  // "GTFS_REALTIME" and "NYCT_SUBWAY_CSV".
  //
  // The are future plans to support plugging in additional custom parsers at
  // build time. This is why the field is a string and not an enum.
  string parser = 8;
  // Additional options for the GTFS realtime parser, if that is the parser in use.
  optional GtfsRealtimeOptions gtfs_realtime_options = 9;
}

// Message describing options for the GTFS realtime parser.
message GtfsRealtimeOptions {
  enum Extension {
    NO_EXTENSION = 0;
    NYCT_TRIPS = 1;
    NYCT_ALERTS = 2;
  }
  Extension extension = 1;

  message NyctTripsOptions {
    bool filter_stale_unassigned_trips = 1;
  }
  optional NyctTripsOptions nyct_trips_options = 2;

  message NyctAlertsOptions {
    enum ElevatorAlertsDeduplicationPolicy {
      NO_DEDUPLICATION = 0;
      DEDUPLICATE_IN_STATION = 1;
      DEDUPLICATE_IN_COMPLEX = 2;
    }
    ElevatorAlertsDeduplicationPolicy elevator_alerts_deduplication_policy = 1;
    bool elevator_alerts_inform_using_station_ids = 2;
    bool skip_timetabled_no_service_alerts = 3;
    bool add_nyct_metadata = 4;
  }
  optional NyctAlertsOptions nyct_alerts_options = 3;

  // If true, stop sequences in the GTFS realtime feed data are ignored, and
  // alternative stop sequences are generated and assigned by Transiter.
  // This setting is designed for buggy GTFS realtime feeds in which
  // stop sequences (incorrectly) change between updates. In many cases
  // Transiter is able to generate stop sequences that are correct and
  // stable across updates.
  //
  // This should not be used for systems where a trip can call at the same
  // stop multiple times.
  bool reassign_stop_sequences = 4;
}

// Description of the configuration for a collection of service maps.
message ServiceMapConfig {
  // Identifier of this service maps config.
  // This must be unique within the system.
  string id = 1;

  // Source describes the possible sources for service maps.
  enum Source {
    // Build the service maps using the GTFS static data.
    STATIC = 0;
    // Build the service maps using the GTFS realtime data.
    REALTIME = 1;
  }
  // Source of the service maps built using this config.
  Source source = 2;

  // The threshold setting is used to exclude one-off trip schedules from service maps.
  // When calculating a service map, all trips are bucketed based on their schedule.
  // If the threshold is 0.2, trips are only included if the corresponding bucket contains
  // at least 20% of the trips. In particular, a one-off trip whose bucket only contains
  // itself will be excluded if there are many other trips.
  //
  // Note that a trip's schedule is reversed if needed based on the direction ID.
  double threshold = 3;

  // Description of options relevent for static service maps only.
  message StaticOptions {
    // If specified, only include trips that start earlier than this time.
    // The time is specified as a number of hours after midnight; i.e., 2:30am is '2.5'.
    optional double starts_earlier_than = 1;
    // If specified, only include trips that start later than this time.
    optional double starts_later_than = 2;
    // If specified, only include trips that end earlier than this time.
    optional double ends_earlier_than = 3;
    // If specified, only include trips that end later than this time.
    optional double ends_later_than = 4;
    // If specified, only include trips which run on at least one of the provided days.
    // If left empty, no trip filtering is provided.
    repeated string days = 5;
  }
  // Additional options relevent for static service maps only.
  optional StaticOptions static_options = 4;
}

message UpdateFeedRequest {
  string system_id = 1;
  string feed_id = 2;
}

message UpdateFeedReply {}

message GetSchedulerStatusRequest {}

message GetSchedulerStatusReply {
  message Feed {
    string system_id = 1;
    string feed_id = 2;
    int64 period = 3;
    int64 last_successful_update = 4;
    int64 last_finished_update = 5;
    bool currently_running = 6;
  }
  repeated Feed feeds = 1;
}

message ResetSchedulerRequest {}

message ResetSchedulerReply {}

message GarbageCollectFeedUpdatesRequest {}

message GarbageCollectFeedUpdatesReply {}
