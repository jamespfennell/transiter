// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: agency_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteStaleAgencies = `-- name: DeleteStaleAgencies :exec
DELETE FROM agency
USING feed_update
WHERE 
    feed_update.pk = agency.source_pk
    AND feed_update.feed_pk = $1
    AND NOT agency.pk = ANY($2::bigint[])
`

type DeleteStaleAgenciesParams struct {
	FeedPk           int64
	UpdatedAgencyPks []int64
}

func (q *Queries) DeleteStaleAgencies(ctx context.Context, arg DeleteStaleAgenciesParams) error {
	_, err := q.db.Exec(ctx, deleteStaleAgencies, arg.FeedPk, arg.UpdatedAgencyPks)
	return err
}

const getAgency = `-- name: GetAgency :one
SELECT agency.pk, agency.id, agency.system_pk, agency.source_pk, agency.name, agency.url, agency.timezone, agency.language, agency.phone, agency.fare_url, agency.email FROM agency
WHERE agency.system_pk = $1
    AND agency.id = $2
`

type GetAgencyParams struct {
	SystemPk int64
	AgencyID string
}

func (q *Queries) GetAgency(ctx context.Context, arg GetAgencyParams) (Agency, error) {
	row := q.db.QueryRow(ctx, getAgency, arg.SystemPk, arg.AgencyID)
	var i Agency
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.SystemPk,
		&i.SourcePk,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Language,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const insertAgency = `-- name: InsertAgency :one
INSERT INTO agency
    (id, system_pk, source_pk, name, url, timezone, language, phone, fare_url, email)
VALUES
    ($1, $2, $3, $4, $5,
     $6, $7, $8, $9, $10)
RETURNING pk
`

type InsertAgencyParams struct {
	ID       string
	SystemPk int64
	SourcePk int64
	Name     string
	Url      string
	Timezone string
	Language pgtype.Text
	Phone    pgtype.Text
	FareUrl  pgtype.Text
	Email    pgtype.Text
}

func (q *Queries) InsertAgency(ctx context.Context, arg InsertAgencyParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgency,
		arg.ID,
		arg.SystemPk,
		arg.SourcePk,
		arg.Name,
		arg.Url,
		arg.Timezone,
		arg.Language,
		arg.Phone,
		arg.FareUrl,
		arg.Email,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

const listAgencies = `-- name: ListAgencies :many
SELECT agency.pk, agency.id, agency.system_pk, agency.source_pk, agency.name, agency.url, agency.timezone, agency.language, agency.phone, agency.fare_url, agency.email FROM agency WHERE system_pk = $1 ORDER BY id
`

func (q *Queries) ListAgencies(ctx context.Context, systemPk int64) ([]Agency, error) {
	rows, err := q.db.Query(ctx, listAgencies, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agency
	for rows.Next() {
		var i Agency
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.SourcePk,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Language,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgenciesByPk = `-- name: ListAgenciesByPk :many
SELECT agency.pk, agency.id, agency.system_pk, agency.source_pk, agency.name, agency.url, agency.timezone, agency.language, agency.phone, agency.fare_url, agency.email FROM agency WHERE pk = ANY($1::bigint[])
`

func (q *Queries) ListAgenciesByPk(ctx context.Context, pk []int64) ([]Agency, error) {
	rows, err := q.db.Query(ctx, listAgenciesByPk, pk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agency
	for rows.Next() {
		var i Agency
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.SourcePk,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Language,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapAgencyPkToId = `-- name: MapAgencyPkToId :many
SELECT pk, id FROM agency WHERE system_pk = $1
`

type MapAgencyPkToIdRow struct {
	Pk int64
	ID string
}

func (q *Queries) MapAgencyPkToId(ctx context.Context, systemPk int64) ([]MapAgencyPkToIdRow, error) {
	rows, err := q.db.Query(ctx, mapAgencyPkToId, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapAgencyPkToIdRow
	for rows.Next() {
		var i MapAgencyPkToIdRow
		if err := rows.Scan(&i.Pk, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAgency = `-- name: UpdateAgency :exec
UPDATE agency SET
    source_pk = $1,
    name = $2,
    url = $3,
    timezone = $4, 
    language = $5, 
    phone = $6, 
    fare_url = $7, 
    email = $8
WHERE
    pk = $9
`

type UpdateAgencyParams struct {
	SourcePk int64
	Name     string
	Url      string
	Timezone string
	Language pgtype.Text
	Phone    pgtype.Text
	FareUrl  pgtype.Text
	Email    pgtype.Text
	Pk       int64
}

func (q *Queries) UpdateAgency(ctx context.Context, arg UpdateAgencyParams) error {
	_, err := q.db.Exec(ctx, updateAgency,
		arg.SourcePk,
		arg.Name,
		arg.Url,
		arg.Timezone,
		arg.Language,
		arg.Phone,
		arg.FareUrl,
		arg.Email,
		arg.Pk,
	)
	return err
}
