// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: trip_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jamespfennell/transiter/db/types"
)

const deleteStaleTrips = `-- name: DeleteStaleTrips :many
DELETE FROM trip
WHERE
    trip.feed_pk = $1
    AND NOT trip.pk = ANY($2::bigint[])
RETURNING trip.route_pk
`

type DeleteStaleTripsParams struct {
	FeedPk         int64
	UpdatedTripPks []int64
}

func (q *Queries) DeleteStaleTrips(ctx context.Context, arg DeleteStaleTripsParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteStaleTrips, arg.FeedPk, arg.UpdatedTripPks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var route_pk int64
		if err := rows.Scan(&route_pk); err != nil {
			return nil, err
		}
		items = append(items, route_pk)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTripStopTimes = `-- name: DeleteTripStopTimes :exec
DELETE FROM trip_stop_time
WHERE pk = ANY($1::bigint[])
`

func (q *Queries) DeleteTripStopTimes(ctx context.Context, pks []int64) error {
	_, err := q.db.Exec(ctx, deleteTripStopTimes, pks)
	return err
}

const getDestinationsForTrips = `-- name: GetDestinationsForTrips :many
WITH last_stop_sequence AS (
  SELECT trip_pk, MAX(stop_sequence) as stop_sequence
    FROM trip_stop_time
    WHERE trip_pk = ANY($1::bigint[])
    GROUP BY trip_pk
)
SELECT lss.trip_pk, stop.pk destination_pk
  FROM last_stop_sequence lss
  INNER JOIN trip_stop_time
    ON lss.trip_pk = trip_stop_time.trip_pk
    AND lss.stop_sequence = trip_stop_time.stop_sequence
  INNER JOIN stop
    ON trip_stop_time.stop_pk = stop.pk
`

type GetDestinationsForTripsRow struct {
	TripPk        int64
	DestinationPk int64
}

func (q *Queries) GetDestinationsForTrips(ctx context.Context, tripPks []int64) ([]GetDestinationsForTripsRow, error) {
	rows, err := q.db.Query(ctx, getDestinationsForTrips, tripPks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDestinationsForTripsRow
	for rows.Next() {
		var i GetDestinationsForTripsRow
		if err := rows.Scan(&i.TripPk, &i.DestinationPk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrip = `-- name: GetTrip :one
WITH shapes_for_scheduled_trips_in_system AS (
  SELECT scheduled_trip.id as trip_id, shape.id as shape_id
  FROM shape
  INNER JOIN scheduled_trip ON shape.pk = scheduled_trip.shape_pk
  WHERE shape.system_pk = $3
)
SELECT trip.pk, trip.id, trip.route_pk, trip.direction_id, trip.started_at, trip.gtfs_hash, trip.feed_pk,
       vehicle.id as vehicle_id,
       vehicle.location::geography as vehicle_location,
       vehicle.bearing as vehicle_bearing,
       vehicle.updated_at as vehicle_updated_at,
       shapes_for_scheduled_trips_in_system.shape_id as shape_id
FROM trip
LEFT JOIN vehicle ON trip.pk = vehicle.trip_pk
LEFT JOIN shapes_for_scheduled_trips_in_system
     ON trip.id = shapes_for_scheduled_trips_in_system.trip_id
WHERE trip.id = $1
    AND trip.route_pk = $2
`

type GetTripParams struct {
	TripID   string
	RoutePk  int64
	SystemPk int64
}

type GetTripRow struct {
	Pk               int64
	ID               string
	RoutePk          int64
	DirectionID      pgtype.Bool
	StartedAt        pgtype.Timestamptz
	GtfsHash         string
	FeedPk           int64
	VehicleID        pgtype.Text
	VehicleLocation  types.Geography
	VehicleBearing   pgtype.Float4
	VehicleUpdatedAt pgtype.Timestamptz
	ShapeID          pgtype.Text
}

func (q *Queries) GetTrip(ctx context.Context, arg GetTripParams) (GetTripRow, error) {
	row := q.db.QueryRow(ctx, getTrip, arg.TripID, arg.RoutePk, arg.SystemPk)
	var i GetTripRow
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.RoutePk,
		&i.DirectionID,
		&i.StartedAt,
		&i.GtfsHash,
		&i.FeedPk,
		&i.VehicleID,
		&i.VehicleLocation,
		&i.VehicleBearing,
		&i.VehicleUpdatedAt,
		&i.ShapeID,
	)
	return i, err
}

const insertTrip = `-- name: InsertTrip :one
INSERT INTO trip
    (id, route_pk, feed_pk, direction_id, started_at, gtfs_hash)
VALUES
    ($1, $2, $3, $4, $5, $6)
RETURNING pk
`

type InsertTripParams struct {
	ID          string
	RoutePk     int64
	FeedPk      int64
	DirectionID pgtype.Bool
	StartedAt   pgtype.Timestamptz
	GtfsHash    string
}

func (q *Queries) InsertTrip(ctx context.Context, arg InsertTripParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTrip,
		arg.ID,
		arg.RoutePk,
		arg.FeedPk,
		arg.DirectionID,
		arg.StartedAt,
		arg.GtfsHash,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

type InsertTripStopTimeParams struct {
	StopPk               int64
	TripPk               int64
	ArrivalTime          pgtype.Timestamptz
	ArrivalDelay         pgtype.Int4
	ArrivalUncertainty   pgtype.Int4
	DepartureTime        pgtype.Timestamptz
	DepartureDelay       pgtype.Int4
	DepartureUncertainty pgtype.Int4
	StopSequence         int32
	Track                pgtype.Text
	Headsign             pgtype.Text
	Past                 bool
}

const listStopsTimesForTrip = `-- name: ListStopsTimesForTrip :many
SELECT trip_stop_time.pk, trip_stop_time.stop_pk, trip_stop_time.trip_pk, trip_stop_time.arrival_time, trip_stop_time.arrival_delay, trip_stop_time.arrival_uncertainty, trip_stop_time.departure_time, trip_stop_time.departure_delay, trip_stop_time.departure_uncertainty, trip_stop_time.stop_sequence, trip_stop_time.track, trip_stop_time.headsign, trip_stop_time.past, stop.id stop_id, stop.name stop_name
FROM trip_stop_time
    INNER JOIN stop ON trip_stop_time.stop_pk = stop.pk
WHERE trip_stop_time.trip_pk = $1
ORDER BY trip_stop_time.stop_sequence ASC
`

type ListStopsTimesForTripRow struct {
	Pk                   int64
	StopPk               int64
	TripPk               int64
	ArrivalTime          pgtype.Timestamptz
	ArrivalDelay         pgtype.Int4
	ArrivalUncertainty   pgtype.Int4
	DepartureTime        pgtype.Timestamptz
	DepartureDelay       pgtype.Int4
	DepartureUncertainty pgtype.Int4
	StopSequence         int32
	Track                pgtype.Text
	Headsign             pgtype.Text
	Past                 bool
	StopID               string
	StopName             pgtype.Text
}

func (q *Queries) ListStopsTimesForTrip(ctx context.Context, tripPk int64) ([]ListStopsTimesForTripRow, error) {
	rows, err := q.db.Query(ctx, listStopsTimesForTrip, tripPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStopsTimesForTripRow
	for rows.Next() {
		var i ListStopsTimesForTripRow
		if err := rows.Scan(
			&i.Pk,
			&i.StopPk,
			&i.TripPk,
			&i.ArrivalTime,
			&i.ArrivalDelay,
			&i.ArrivalUncertainty,
			&i.DepartureTime,
			&i.DepartureDelay,
			&i.DepartureUncertainty,
			&i.StopSequence,
			&i.Track,
			&i.Headsign,
			&i.Past,
			&i.StopID,
			&i.StopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTripPksInSystem = `-- name: ListTripPksInSystem :many
SELECT trip.id, trip.pk
FROM trip
    INNER JOIN feed ON trip.feed_pk = feed.pk
WHERE trip.id = ANY($1::text[])
    AND feed.system_pk = $2
`

type ListTripPksInSystemParams struct {
	TripIds  []string
	SystemPk int64
}

type ListTripPksInSystemRow struct {
	ID string
	Pk int64
}

func (q *Queries) ListTripPksInSystem(ctx context.Context, arg ListTripPksInSystemParams) ([]ListTripPksInSystemRow, error) {
	rows, err := q.db.Query(ctx, listTripPksInSystem, arg.TripIds, arg.SystemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTripPksInSystemRow
	for rows.Next() {
		var i ListTripPksInSystemRow
		if err := rows.Scan(&i.ID, &i.Pk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTripStopTimesForUpdate = `-- name: ListTripStopTimesForUpdate :many
SELECT pk, trip_pk, stop_pk, stop_sequence, past FROM trip_stop_time
WHERE trip_pk = ANY($1::bigint[])
ORDER BY trip_pk, stop_sequence
`

type ListTripStopTimesForUpdateRow struct {
	Pk           int64
	TripPk       int64
	StopPk       int64
	StopSequence int32
	Past         bool
}

func (q *Queries) ListTripStopTimesForUpdate(ctx context.Context, tripPks []int64) ([]ListTripStopTimesForUpdateRow, error) {
	rows, err := q.db.Query(ctx, listTripStopTimesForUpdate, tripPks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTripStopTimesForUpdateRow
	for rows.Next() {
		var i ListTripStopTimesForUpdateRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.StopPk,
			&i.StopSequence,
			&i.Past,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrips = `-- name: ListTrips :many
WITH shapes_for_scheduled_trips_in_system AS (
  SELECT scheduled_trip.id as trip_id, shape.id as shape_id
  FROM shape
  INNER JOIN scheduled_trip ON shape.pk = scheduled_trip.shape_pk
  WHERE shape.system_pk = $2
)
SELECT trip.pk, trip.id, trip.route_pk, trip.direction_id, trip.started_at, trip.gtfs_hash, trip.feed_pk,
       vehicle.id as vehicle_id,
       vehicle.location::geography as vehicle_location,
       vehicle.bearing as vehicle_bearing,
       vehicle.updated_at as vehicle_updated_at,
       shapes_for_scheduled_trips_in_system.shape_id as shape_id
FROM trip
LEFT JOIN vehicle ON trip.pk = vehicle.trip_pk
LEFT JOIN shapes_for_scheduled_trips_in_system
     ON trip.id = shapes_for_scheduled_trips_in_system.trip_id
WHERE trip.route_pk = ANY($1::bigint[])
ORDER BY trip.route_pk, trip.id
`

type ListTripsParams struct {
	RoutePks []int64
	SystemPk int64
}

type ListTripsRow struct {
	Pk               int64
	ID               string
	RoutePk          int64
	DirectionID      pgtype.Bool
	StartedAt        pgtype.Timestamptz
	GtfsHash         string
	FeedPk           int64
	VehicleID        pgtype.Text
	VehicleLocation  types.Geography
	VehicleBearing   pgtype.Float4
	VehicleUpdatedAt pgtype.Timestamptz
	ShapeID          pgtype.Text
}

func (q *Queries) ListTrips(ctx context.Context, arg ListTripsParams) ([]ListTripsRow, error) {
	rows, err := q.db.Query(ctx, listTrips, arg.RoutePks, arg.SystemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTripsRow
	for rows.Next() {
		var i ListTripsRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.RoutePk,
			&i.DirectionID,
			&i.StartedAt,
			&i.GtfsHash,
			&i.FeedPk,
			&i.VehicleID,
			&i.VehicleLocation,
			&i.VehicleBearing,
			&i.VehicleUpdatedAt,
			&i.ShapeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapTripIDToPkInSystem = `-- name: MapTripIDToPkInSystem :many
SELECT trip.id, trip.pk
FROM trip
    INNER JOIN feed ON trip.feed_pk = feed.pk
WHERE trip.id = ANY($1::text[])
    AND feed.system_pk = $2
FOR UPDATE
`

type MapTripIDToPkInSystemParams struct {
	TripIds  []string
	SystemPk int64
}

type MapTripIDToPkInSystemRow struct {
	ID string
	Pk int64
}

func (q *Queries) MapTripIDToPkInSystem(ctx context.Context, arg MapTripIDToPkInSystemParams) ([]MapTripIDToPkInSystemRow, error) {
	rows, err := q.db.Query(ctx, mapTripIDToPkInSystem, arg.TripIds, arg.SystemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapTripIDToPkInSystemRow
	for rows.Next() {
		var i MapTripIDToPkInSystemRow
		if err := rows.Scan(&i.ID, &i.Pk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTripStopTime = `-- name: UpdateTripStopTime :exec
UPDATE trip_stop_time
SET
    stop_pk = $1,
    arrival_time = $2,
    arrival_delay = $3,
    arrival_uncertainty = $4,
    departure_time = $5,
    departure_delay = $6,
    departure_uncertainty = $7,
    stop_sequence = $8,
    track = $9,
    headsign = $10,
    past = FALSE
WHERE
    pk = $11
`

type UpdateTripStopTimeParams struct {
	StopPk               int64
	ArrivalTime          pgtype.Timestamptz
	ArrivalDelay         pgtype.Int4
	ArrivalUncertainty   pgtype.Int4
	DepartureTime        pgtype.Timestamptz
	DepartureDelay       pgtype.Int4
	DepartureUncertainty pgtype.Int4
	StopSequence         int32
	Track                pgtype.Text
	Headsign             pgtype.Text
	Pk                   int64
}

func (q *Queries) UpdateTripStopTime(ctx context.Context, arg UpdateTripStopTimeParams) error {
	_, err := q.db.Exec(ctx, updateTripStopTime,
		arg.StopPk,
		arg.ArrivalTime,
		arg.ArrivalDelay,
		arg.ArrivalUncertainty,
		arg.DepartureTime,
		arg.DepartureDelay,
		arg.DepartureUncertainty,
		arg.StopSequence,
		arg.Track,
		arg.Headsign,
		arg.Pk,
	)
	return err
}
