// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: schedule_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteScheduledServices = `-- name: DeleteScheduledServices :exec
DELETE FROM scheduled_service
WHERE feed_pk = $1
OR (system_pk = $2 AND
   id = ANY($3::text[]))
`

type DeleteScheduledServicesParams struct {
	FeedPk            int64
	SystemPk          int64
	UpdatedServiceIds []string
}

func (q *Queries) DeleteScheduledServices(ctx context.Context, arg DeleteScheduledServicesParams) error {
	_, err := q.db.Exec(ctx, deleteScheduledServices, arg.FeedPk, arg.SystemPk, arg.UpdatedServiceIds)
	return err
}

const getScheduledService = `-- name: GetScheduledService :one
SELECT pk, id, system_pk, monday, tuesday, wednesday, thursday, friday, saturday, sunday, end_date, start_date, feed_pk from scheduled_service
WHERE system_pk = $1
AND id = $2
`

type GetScheduledServiceParams struct {
	SystemPk int64
	ID       string
}

func (q *Queries) GetScheduledService(ctx context.Context, arg GetScheduledServiceParams) (ScheduledService, error) {
	row := q.db.QueryRow(ctx, getScheduledService, arg.SystemPk, arg.ID)
	var i ScheduledService
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.SystemPk,
		&i.Monday,
		&i.Tuesday,
		&i.Wednesday,
		&i.Thursday,
		&i.Friday,
		&i.Saturday,
		&i.Sunday,
		&i.EndDate,
		&i.StartDate,
		&i.FeedPk,
	)
	return i, err
}

const getScheduledTrip = `-- name: GetScheduledTrip :one
SELECT scheduled_trip.pk, scheduled_trip.id, scheduled_trip.route_pk, scheduled_trip.service_pk, scheduled_trip.direction_id, scheduled_trip.bikes_allowed, scheduled_trip.block_id, scheduled_trip.headsign, scheduled_trip.short_name, scheduled_trip.wheelchair_accessible, scheduled_trip.shape_pk
FROM scheduled_trip
INNER JOIN route ON scheduled_trip.route_pk = route.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
AND scheduled_trip.id = $2
`

type GetScheduledTripParams struct {
	SystemPk int64
	TripID   string
}

func (q *Queries) GetScheduledTrip(ctx context.Context, arg GetScheduledTripParams) (ScheduledTrip, error) {
	row := q.db.QueryRow(ctx, getScheduledTrip, arg.SystemPk, arg.TripID)
	var i ScheduledTrip
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.RoutePk,
		&i.ServicePk,
		&i.DirectionID,
		&i.BikesAllowed,
		&i.BlockID,
		&i.Headsign,
		&i.ShortName,
		&i.WheelchairAccessible,
		&i.ShapePk,
	)
	return i, err
}

const insertScheduledService = `-- name: InsertScheduledService :one
INSERT INTO scheduled_service
    (id, system_pk, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date, feed_pk)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING pk
`

type InsertScheduledServiceParams struct {
	ID        string
	SystemPk  int64
	Monday    pgtype.Bool
	Tuesday   pgtype.Bool
	Wednesday pgtype.Bool
	Thursday  pgtype.Bool
	Friday    pgtype.Bool
	Saturday  pgtype.Bool
	Sunday    pgtype.Bool
	StartDate pgtype.Date
	EndDate   pgtype.Date
	FeedPk    int64
}

func (q *Queries) InsertScheduledService(ctx context.Context, arg InsertScheduledServiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertScheduledService,
		arg.ID,
		arg.SystemPk,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.StartDate,
		arg.EndDate,
		arg.FeedPk,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

const insertScheduledServiceAddition = `-- name: InsertScheduledServiceAddition :exec
INSERT INTO scheduled_service_addition
    (service_pk, date)
VALUES
    ($1, $2)
`

type InsertScheduledServiceAdditionParams struct {
	ServicePk int64
	Date      pgtype.Date
}

func (q *Queries) InsertScheduledServiceAddition(ctx context.Context, arg InsertScheduledServiceAdditionParams) error {
	_, err := q.db.Exec(ctx, insertScheduledServiceAddition, arg.ServicePk, arg.Date)
	return err
}

const insertScheduledServiceRemoval = `-- name: InsertScheduledServiceRemoval :exec
INSERT INTO scheduled_service_removal
    (service_pk, date)
VALUES
    ($1, $2)
`

type InsertScheduledServiceRemovalParams struct {
	ServicePk int64
	Date      pgtype.Date
}

func (q *Queries) InsertScheduledServiceRemoval(ctx context.Context, arg InsertScheduledServiceRemovalParams) error {
	_, err := q.db.Exec(ctx, insertScheduledServiceRemoval, arg.ServicePk, arg.Date)
	return err
}

type InsertScheduledTripParams struct {
	ID                   string
	RoutePk              int64
	ServicePk            int64
	ShapePk              pgtype.Int8
	DirectionID          pgtype.Bool
	BikesAllowed         pgtype.Bool
	BlockID              pgtype.Text
	Headsign             pgtype.Text
	ShortName            pgtype.Text
	WheelchairAccessible pgtype.Bool
}

const insertScheduledTripFrequency = `-- name: InsertScheduledTripFrequency :exec
INSERT INTO scheduled_trip_frequency
    (trip_pk, start_time, end_time, headway, frequency_based)
VALUES
    ($1, $2, $3, $4, $5)
`

type InsertScheduledTripFrequencyParams struct {
	TripPk         int64
	StartTime      int32
	EndTime        int32
	Headway        int32
	FrequencyBased bool
}

func (q *Queries) InsertScheduledTripFrequency(ctx context.Context, arg InsertScheduledTripFrequencyParams) error {
	_, err := q.db.Exec(ctx, insertScheduledTripFrequency,
		arg.TripPk,
		arg.StartTime,
		arg.EndTime,
		arg.Headway,
		arg.FrequencyBased,
	)
	return err
}

type InsertScheduledTripStopTimeParams struct {
	TripPk                int64
	StopPk                int64
	ArrivalTime           pgtype.Int4
	DepartureTime         pgtype.Int4
	StopSequence          int32
	ContinuousDropOff     string
	ContinuousPickup      string
	DropOffType           string
	ExactTimes            bool
	Headsign              pgtype.Text
	PickupType            string
	ShapeDistanceTraveled pgtype.Float8
}

const listScheduledServices = `-- name: ListScheduledServices :many
SELECT scheduled_service.pk, scheduled_service.id, scheduled_service.system_pk, scheduled_service.monday, scheduled_service.tuesday, scheduled_service.wednesday, scheduled_service.thursday, scheduled_service.friday, scheduled_service.saturday, scheduled_service.sunday, scheduled_service.end_date, scheduled_service.start_date, scheduled_service.feed_pk,
       scheduled_service_addition.additions AS additions,
       scheduled_service_removal.removals AS removals
FROM scheduled_service
LEFT JOIN (SELECT service_pk,
                  CASE WHEN COUNT(scheduled_service_addition.date) > 0
                  THEN array_agg(scheduled_service_addition.date ORDER BY scheduled_service_addition.date)::date[]
                  ELSE NULL::date[] END AS additions
           FROM scheduled_service_addition
           GROUP BY scheduled_service_addition.service_pk) AS scheduled_service_addition
    ON scheduled_service.pk = scheduled_service_addition.service_pk
LEFT JOIN (SELECT service_pk,
                  CASE WHEN COUNT(scheduled_service_removal.date) > 0
                  THEN array_agg(scheduled_service_removal.date ORDER BY scheduled_service_removal.date)::date[]
                  ELSE NULL::date[] END AS removals
           FROM scheduled_service_removal
           GROUP BY scheduled_service_removal.service_pk) AS scheduled_service_removal
    ON scheduled_service.pk = scheduled_service_removal.service_pk
WHERE system_pk = $1
`

type ListScheduledServicesRow struct {
	Pk        int64
	ID        string
	SystemPk  int64
	Monday    pgtype.Bool
	Tuesday   pgtype.Bool
	Wednesday pgtype.Bool
	Thursday  pgtype.Bool
	Friday    pgtype.Bool
	Saturday  pgtype.Bool
	Sunday    pgtype.Bool
	EndDate   pgtype.Date
	StartDate pgtype.Date
	FeedPk    int64
	Additions []pgtype.Date
	Removals  []pgtype.Date
}

func (q *Queries) ListScheduledServices(ctx context.Context, systemPk int64) ([]ListScheduledServicesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledServices, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledServicesRow
	for rows.Next() {
		var i ListScheduledServicesRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
			&i.Sunday,
			&i.EndDate,
			&i.StartDate,
			&i.FeedPk,
			&i.Additions,
			&i.Removals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTripFrequencies = `-- name: ListScheduledTripFrequencies :many
SELECT
    scheduled_trip_frequency.pk, scheduled_trip_frequency.trip_pk, scheduled_trip_frequency.headway, scheduled_trip_frequency.frequency_based, scheduled_trip_frequency.start_time, scheduled_trip_frequency.end_time,
    scheduled_trip.id trip_id
FROM scheduled_trip_frequency
INNER JOIN scheduled_trip ON scheduled_trip_frequency.trip_pk = scheduled_trip.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripFrequenciesRow struct {
	Pk             int64
	TripPk         int64
	Headway        int32
	FrequencyBased bool
	StartTime      int32
	EndTime        int32
	TripID         string
}

func (q *Queries) ListScheduledTripFrequencies(ctx context.Context, systemPk int64) ([]ListScheduledTripFrequenciesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTripFrequencies, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripFrequenciesRow
	for rows.Next() {
		var i ListScheduledTripFrequenciesRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.Headway,
			&i.FrequencyBased,
			&i.StartTime,
			&i.EndTime,
			&i.TripID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTripStopTimes = `-- name: ListScheduledTripStopTimes :many
SELECT
    scheduled_trip_stop_time.pk, scheduled_trip_stop_time.trip_pk, scheduled_trip_stop_time.stop_pk, scheduled_trip_stop_time.stop_sequence, scheduled_trip_stop_time.continuous_drop_off, scheduled_trip_stop_time.continuous_pickup, scheduled_trip_stop_time.drop_off_type, scheduled_trip_stop_time.exact_times, scheduled_trip_stop_time.headsign, scheduled_trip_stop_time.pickup_type, scheduled_trip_stop_time.shape_distance_traveled, scheduled_trip_stop_time.arrival_time, scheduled_trip_stop_time.departure_time,
    scheduled_trip.id trip_id,
    stop.id stop_id
FROM scheduled_trip_stop_time
INNER JOIN scheduled_trip ON scheduled_trip_stop_time.trip_pk = scheduled_trip.pk
INNER JOIN stop ON scheduled_trip_stop_time.stop_pk = stop.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripStopTimesRow struct {
	Pk                    int64
	TripPk                int64
	StopPk                int64
	StopSequence          int32
	ContinuousDropOff     string
	ContinuousPickup      string
	DropOffType           string
	ExactTimes            bool
	Headsign              pgtype.Text
	PickupType            string
	ShapeDistanceTraveled pgtype.Float8
	ArrivalTime           pgtype.Int4
	DepartureTime         pgtype.Int4
	TripID                string
	StopID                string
}

func (q *Queries) ListScheduledTripStopTimes(ctx context.Context, systemPk int64) ([]ListScheduledTripStopTimesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTripStopTimes, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripStopTimesRow
	for rows.Next() {
		var i ListScheduledTripStopTimesRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.StopPk,
			&i.StopSequence,
			&i.ContinuousDropOff,
			&i.ContinuousPickup,
			&i.DropOffType,
			&i.ExactTimes,
			&i.Headsign,
			&i.PickupType,
			&i.ShapeDistanceTraveled,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.TripID,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTrips = `-- name: ListScheduledTrips :many
SELECT
    scheduled_trip.pk, scheduled_trip.id, scheduled_trip.route_pk, scheduled_trip.service_pk, scheduled_trip.direction_id, scheduled_trip.bikes_allowed, scheduled_trip.block_id, scheduled_trip.headsign, scheduled_trip.short_name, scheduled_trip.wheelchair_accessible, scheduled_trip.shape_pk,
    route.id route_id,
    scheduled_service.id service_id
FROM scheduled_trip
INNER JOIN route ON scheduled_trip.route_pk = route.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripsRow struct {
	Pk                   int64
	ID                   string
	RoutePk              int64
	ServicePk            int64
	DirectionID          pgtype.Bool
	BikesAllowed         pgtype.Bool
	BlockID              pgtype.Text
	Headsign             pgtype.Text
	ShortName            pgtype.Text
	WheelchairAccessible pgtype.Bool
	ShapePk              pgtype.Int8
	RouteID              string
	ServiceID            string
}

func (q *Queries) ListScheduledTrips(ctx context.Context, systemPk int64) ([]ListScheduledTripsRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTrips, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripsRow
	for rows.Next() {
		var i ListScheduledTripsRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.RoutePk,
			&i.ServicePk,
			&i.DirectionID,
			&i.BikesAllowed,
			&i.BlockID,
			&i.Headsign,
			&i.ShortName,
			&i.WheelchairAccessible,
			&i.ShapePk,
			&i.RouteID,
			&i.ServiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapScheduledTripIDToPkInSystem = `-- name: MapScheduledTripIDToPkInSystem :many
SELECT scheduled_trip.id, scheduled_trip.pk FROM scheduled_trip
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE
    system_pk = $1
    AND (
        NOT $2::bool
        OR scheduled_trip.id = ANY($3::text[])
    )
`

type MapScheduledTripIDToPkInSystemParams struct {
	SystemPk       int64
	FilterByTripID bool
	TripIds        []string
}

type MapScheduledTripIDToPkInSystemRow struct {
	ID string
	Pk int64
}

func (q *Queries) MapScheduledTripIDToPkInSystem(ctx context.Context, arg MapScheduledTripIDToPkInSystemParams) ([]MapScheduledTripIDToPkInSystemRow, error) {
	rows, err := q.db.Query(ctx, mapScheduledTripIDToPkInSystem, arg.SystemPk, arg.FilterByTripID, arg.TripIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapScheduledTripIDToPkInSystemRow
	for rows.Next() {
		var i MapScheduledTripIDToPkInSystemRow
		if err := rows.Scan(&i.ID, &i.Pk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapScheduledTripIDToRoutePkInSystem = `-- name: MapScheduledTripIDToRoutePkInSystem :many
SELECT scheduled_trip.id, scheduled_trip.route_pk FROM scheduled_trip
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE
    system_pk = $1
    AND (
        NOT $2::bool
        OR scheduled_trip.id = ANY($3::text[])
    )
`

type MapScheduledTripIDToRoutePkInSystemParams struct {
	SystemPk       int64
	FilterByTripID bool
	TripIds        []string
}

type MapScheduledTripIDToRoutePkInSystemRow struct {
	ID      string
	RoutePk int64
}

func (q *Queries) MapScheduledTripIDToRoutePkInSystem(ctx context.Context, arg MapScheduledTripIDToRoutePkInSystemParams) ([]MapScheduledTripIDToRoutePkInSystemRow, error) {
	rows, err := q.db.Query(ctx, mapScheduledTripIDToRoutePkInSystem, arg.SystemPk, arg.FilterByTripID, arg.TripIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapScheduledTripIDToRoutePkInSystemRow
	for rows.Next() {
		var i MapScheduledTripIDToRoutePkInSystemRow
		if err := rows.Scan(&i.ID, &i.RoutePk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
