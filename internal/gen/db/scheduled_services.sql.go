// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: scheduled_services.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteScheduledServiceAdditions = `-- name: DeleteScheduledServiceAdditions :exec
DELETE FROM scheduled_service_addition
USING scheduled_service
WHERE scheduled_service.pk = scheduled_service_addition.service_pk
AND feed_pk = $1
`

func (q *Queries) DeleteScheduledServiceAdditions(ctx context.Context, feedPk int64) error {
	_, err := q.db.Exec(ctx, deleteScheduledServiceAdditions, feedPk)
	return err
}

const deleteScheduledServiceRemovals = `-- name: DeleteScheduledServiceRemovals :exec
DELETE FROM scheduled_service_removal
USING scheduled_service
WHERE scheduled_service.pk = scheduled_service_removal.service_pk
AND feed_pk = $1
`

func (q *Queries) DeleteScheduledServiceRemovals(ctx context.Context, feedPk int64) error {
	_, err := q.db.Exec(ctx, deleteScheduledServiceRemovals, feedPk)
	return err
}

const deleteStaleScheduledServices = `-- name: DeleteStaleScheduledServices :exec
DELETE FROM scheduled_service
WHERE
    feed_pk = $1
    AND NOT pk = ANY($2::bigint[])
`

type DeleteStaleScheduledServicesParams struct {
	FeedPk                     int64
	UpdatedScheduledServicePks []int64
}

func (q *Queries) DeleteStaleScheduledServices(ctx context.Context, arg DeleteStaleScheduledServicesParams) error {
	_, err := q.db.Exec(ctx, deleteStaleScheduledServices, arg.FeedPk, arg.UpdatedScheduledServicePks)
	return err
}

const insertScheduledService = `-- name: InsertScheduledService :one
INSERT INTO scheduled_service
    (id, system_pk, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date, feed_pk)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING pk
`

type InsertScheduledServiceParams struct {
	ID        string
	SystemPk  int64
	Monday    pgtype.Bool
	Tuesday   pgtype.Bool
	Wednesday pgtype.Bool
	Thursday  pgtype.Bool
	Friday    pgtype.Bool
	Saturday  pgtype.Bool
	Sunday    pgtype.Bool
	StartDate pgtype.Date
	EndDate   pgtype.Date
	FeedPk    int64
}

func (q *Queries) InsertScheduledService(ctx context.Context, arg InsertScheduledServiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertScheduledService,
		arg.ID,
		arg.SystemPk,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.StartDate,
		arg.EndDate,
		arg.FeedPk,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

const insertScheduledServiceAddition = `-- name: InsertScheduledServiceAddition :exec
INSERT INTO scheduled_service_addition
    (service_pk, date)
VALUES
    ($1, $2)
`

type InsertScheduledServiceAdditionParams struct {
	ServicePk int64
	Date      pgtype.Date
}

func (q *Queries) InsertScheduledServiceAddition(ctx context.Context, arg InsertScheduledServiceAdditionParams) error {
	_, err := q.db.Exec(ctx, insertScheduledServiceAddition, arg.ServicePk, arg.Date)
	return err
}

const insertScheduledServiceRemoval = `-- name: InsertScheduledServiceRemoval :exec
INSERT INTO scheduled_service_removal
    (service_pk, date)
VALUES
    ($1, $2)
`

type InsertScheduledServiceRemovalParams struct {
	ServicePk int64
	Date      pgtype.Date
}

func (q *Queries) InsertScheduledServiceRemoval(ctx context.Context, arg InsertScheduledServiceRemovalParams) error {
	_, err := q.db.Exec(ctx, insertScheduledServiceRemoval, arg.ServicePk, arg.Date)
	return err
}

const listScheduledServices = `-- name: ListScheduledServices :many
SELECT scheduled_service.pk, scheduled_service.id, scheduled_service.system_pk, scheduled_service.monday, scheduled_service.tuesday, scheduled_service.wednesday, scheduled_service.thursday, scheduled_service.friday, scheduled_service.saturday, scheduled_service.sunday, scheduled_service.end_date, scheduled_service.start_date, scheduled_service.feed_pk,
       scheduled_service_addition.additions AS additions,
       scheduled_service_removal.removals AS removals
FROM scheduled_service
LEFT JOIN (SELECT service_pk,
                  CASE WHEN COUNT(scheduled_service_addition.date) > 0
                  THEN array_agg(scheduled_service_addition.date ORDER BY scheduled_service_addition.date)::date[]
                  ELSE NULL::date[] END AS additions
           FROM scheduled_service_addition
           GROUP BY scheduled_service_addition.service_pk) AS scheduled_service_addition
    ON scheduled_service.pk = scheduled_service_addition.service_pk
LEFT JOIN (SELECT service_pk,
                  CASE WHEN COUNT(scheduled_service_removal.date) > 0
                  THEN array_agg(scheduled_service_removal.date ORDER BY scheduled_service_removal.date)::date[]
                  ELSE NULL::date[] END AS removals
           FROM scheduled_service_removal
           GROUP BY scheduled_service_removal.service_pk) AS scheduled_service_removal
    ON scheduled_service.pk = scheduled_service_removal.service_pk
WHERE system_pk = $1
`

type ListScheduledServicesRow struct {
	Pk        int64
	ID        string
	SystemPk  int64
	Monday    pgtype.Bool
	Tuesday   pgtype.Bool
	Wednesday pgtype.Bool
	Thursday  pgtype.Bool
	Friday    pgtype.Bool
	Saturday  pgtype.Bool
	Sunday    pgtype.Bool
	EndDate   pgtype.Date
	StartDate pgtype.Date
	FeedPk    int64
	Additions []pgtype.Date
	Removals  []pgtype.Date
}

func (q *Queries) ListScheduledServices(ctx context.Context, systemPk int64) ([]ListScheduledServicesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledServices, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledServicesRow
	for rows.Next() {
		var i ListScheduledServicesRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
			&i.Sunday,
			&i.EndDate,
			&i.StartDate,
			&i.FeedPk,
			&i.Additions,
			&i.Removals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapScheduledServiceIDToPkInSystem = `-- name: MapScheduledServiceIDToPkInSystem :many
SELECT id, pk FROM scheduled_service
WHERE
    system_pk = $1
    AND (
        NOT $2::bool
        OR id = ANY($3::text[])
    )
`

type MapScheduledServiceIDToPkInSystemParams struct {
	SystemPk                   int64
	FilterByScheduledServiceID bool
	ScheduledServiceIds        []string
}

type MapScheduledServiceIDToPkInSystemRow struct {
	ID string
	Pk int64
}

func (q *Queries) MapScheduledServiceIDToPkInSystem(ctx context.Context, arg MapScheduledServiceIDToPkInSystemParams) ([]MapScheduledServiceIDToPkInSystemRow, error) {
	rows, err := q.db.Query(ctx, mapScheduledServiceIDToPkInSystem, arg.SystemPk, arg.FilterByScheduledServiceID, arg.ScheduledServiceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapScheduledServiceIDToPkInSystemRow
	for rows.Next() {
		var i MapScheduledServiceIDToPkInSystemRow
		if err := rows.Scan(&i.ID, &i.Pk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledService = `-- name: UpdateScheduledService :exec
UPDATE scheduled_service SET
    system_pk = $1,
    monday = $2,
    tuesday = $3,
    wednesday = $4,
    thursday = $5,
    friday = $6,
    saturday = $7,
    sunday = $8,
    start_date = $9,
    end_date = $10,
    feed_pk = $11
WHERE pk = $12
`

type UpdateScheduledServiceParams struct {
	SystemPk  int64
	Monday    pgtype.Bool
	Tuesday   pgtype.Bool
	Wednesday pgtype.Bool
	Thursday  pgtype.Bool
	Friday    pgtype.Bool
	Saturday  pgtype.Bool
	Sunday    pgtype.Bool
	StartDate pgtype.Date
	EndDate   pgtype.Date
	FeedPk    int64
	Pk        int64
}

func (q *Queries) UpdateScheduledService(ctx context.Context, arg UpdateScheduledServiceParams) error {
	_, err := q.db.Exec(ctx, updateScheduledService,
		arg.SystemPk,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.StartDate,
		arg.EndDate,
		arg.FeedPk,
		arg.Pk,
	)
	return err
}
