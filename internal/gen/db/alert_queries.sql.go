// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: alert_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAlerts = `-- name: DeleteAlerts :exec
DELETE FROM alert WHERE pk = ANY($1::bigint[])
`

func (q *Queries) DeleteAlerts(ctx context.Context, alertPks []int64) error {
	_, err := q.db.Exec(ctx, deleteAlerts, alertPks)
	return err
}

const deleteStaleAlerts = `-- name: DeleteStaleAlerts :exec
DELETE FROM alert
WHERE
    alert.feed_pk = $1
    AND NOT alert.pk = ANY($2::bigint[])
`

type DeleteStaleAlertsParams struct {
	FeedPk          int64
	UpdatedAlertPks []int64
}

func (q *Queries) DeleteStaleAlerts(ctx context.Context, arg DeleteStaleAlertsParams) error {
	_, err := q.db.Exec(ctx, deleteStaleAlerts, arg.FeedPk, arg.UpdatedAlertPks)
	return err
}

const getAlertInSystem = `-- name: GetAlertInSystem :one
SELECT alert.pk, alert.id, alert.system_pk, alert.cause, alert.effect, alert.header, alert.description, alert.url, alert.hash, alert.feed_pk FROM alert WHERE alert.system_pk = $1 AND alert.id = $2
`

type GetAlertInSystemParams struct {
	SystemPk int64
	AlertID  string
}

func (q *Queries) GetAlertInSystem(ctx context.Context, arg GetAlertInSystemParams) (Alert, error) {
	row := q.db.QueryRow(ctx, getAlertInSystem, arg.SystemPk, arg.AlertID)
	var i Alert
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.SystemPk,
		&i.Cause,
		&i.Effect,
		&i.Header,
		&i.Description,
		&i.Url,
		&i.Hash,
		&i.FeedPk,
	)
	return i, err
}

const insertAlert = `-- name: InsertAlert :one
INSERT INTO alert
    (id, system_pk, feed_pk, cause, effect, header, description, url, hash)
VALUES
    ($1, $2, $3, $4,$5,
     $6, $7, $8, $9)
RETURNING pk
`

type InsertAlertParams struct {
	ID          string
	SystemPk    int64
	FeedPk      int64
	Cause       string
	Effect      string
	Header      string
	Description string
	Url         string
	Hash        string
}

func (q *Queries) InsertAlert(ctx context.Context, arg InsertAlertParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAlert,
		arg.ID,
		arg.SystemPk,
		arg.FeedPk,
		arg.Cause,
		arg.Effect,
		arg.Header,
		arg.Description,
		arg.Url,
		arg.Hash,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

const insertAlertActivePeriod = `-- name: InsertAlertActivePeriod :exec
INSERT INTO alert_active_period
    (alert_pk, starts_at, ends_at)
VALUES
    ($1, $2, $3)
`

type InsertAlertActivePeriodParams struct {
	AlertPk  int64
	StartsAt pgtype.Timestamptz
	EndsAt   pgtype.Timestamptz
}

func (q *Queries) InsertAlertActivePeriod(ctx context.Context, arg InsertAlertActivePeriodParams) error {
	_, err := q.db.Exec(ctx, insertAlertActivePeriod, arg.AlertPk, arg.StartsAt, arg.EndsAt)
	return err
}

const insertAlertAgency = `-- name: InsertAlertAgency :exec
INSERT INTO alert_agency (alert_pk, agency_pk) VALUES ($1, $2)
`

type InsertAlertAgencyParams struct {
	AlertPk  int64
	AgencyPk int64
}

func (q *Queries) InsertAlertAgency(ctx context.Context, arg InsertAlertAgencyParams) error {
	_, err := q.db.Exec(ctx, insertAlertAgency, arg.AlertPk, arg.AgencyPk)
	return err
}

const insertAlertRoute = `-- name: InsertAlertRoute :exec
INSERT INTO alert_route (alert_pk, route_pk) VALUES ($1, $2)
`

type InsertAlertRouteParams struct {
	AlertPk int64
	RoutePk int64
}

func (q *Queries) InsertAlertRoute(ctx context.Context, arg InsertAlertRouteParams) error {
	_, err := q.db.Exec(ctx, insertAlertRoute, arg.AlertPk, arg.RoutePk)
	return err
}

const insertAlertRouteType = `-- name: InsertAlertRouteType :exec
INSERT INTO alert_route_type (alert_pk, route_type) VALUES ($1, $2)
`

type InsertAlertRouteTypeParams struct {
	AlertPk   int64
	RouteType string
}

func (q *Queries) InsertAlertRouteType(ctx context.Context, arg InsertAlertRouteTypeParams) error {
	_, err := q.db.Exec(ctx, insertAlertRouteType, arg.AlertPk, arg.RouteType)
	return err
}

const insertAlertStop = `-- name: InsertAlertStop :exec
INSERT INTO alert_stop (alert_pk, stop_pk) VALUES ($1, $2)
`

type InsertAlertStopParams struct {
	AlertPk int64
	StopPk  int64
}

func (q *Queries) InsertAlertStop(ctx context.Context, arg InsertAlertStopParams) error {
	_, err := q.db.Exec(ctx, insertAlertStop, arg.AlertPk, arg.StopPk)
	return err
}

const insertAlertTrip = `-- name: InsertAlertTrip :exec
INSERT INTO alert_trip (alert_pk, trip_pk, scheduled_trip_pk) VALUES ($1, $2, $3)
`

type InsertAlertTripParams struct {
	AlertPk         int64
	TripPk          pgtype.Int8
	ScheduledTripPk pgtype.Int8
}

func (q *Queries) InsertAlertTrip(ctx context.Context, arg InsertAlertTripParams) error {
	_, err := q.db.Exec(ctx, insertAlertTrip, arg.AlertPk, arg.TripPk, arg.ScheduledTripPk)
	return err
}

const listActiveAlertsForAgencies = `-- name: ListActiveAlertsForAgencies :many
SELECT alert.id, alert.cause, alert.effect
FROM alert_agency
    INNER JOIN alert ON alert_agency.alert_pk = alert.pk
WHERE alert_agency.agency_pk = ANY($1::bigint[])
    AND EXISTS (
        SELECT 1 FROM alert_active_period
        WHERE alert_active_period.alert_pk = alert.pk
        AND (
            alert_active_period.starts_at < $2
            OR alert_active_period.starts_at IS NULL
        )
        AND (
            alert_active_period.ends_at > $2
            OR alert_active_period.ends_at IS NULL
        )
    )
`

type ListActiveAlertsForAgenciesParams struct {
	AgencyPks   []int64
	PresentTime pgtype.Timestamptz
}

type ListActiveAlertsForAgenciesRow struct {
	ID     string
	Cause  string
	Effect string
}

func (q *Queries) ListActiveAlertsForAgencies(ctx context.Context, arg ListActiveAlertsForAgenciesParams) ([]ListActiveAlertsForAgenciesRow, error) {
	rows, err := q.db.Query(ctx, listActiveAlertsForAgencies, arg.AgencyPks, arg.PresentTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveAlertsForAgenciesRow
	for rows.Next() {
		var i ListActiveAlertsForAgenciesRow
		if err := rows.Scan(&i.ID, &i.Cause, &i.Effect); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAlertsForRoutes = `-- name: ListActiveAlertsForRoutes :many
SELECT route.pk route_pk, alert.id, alert.cause, alert.effect
FROM route
    INNER JOIN alert_route ON route.pk = alert_route.route_pk
    INNER JOIN alert ON alert_route.alert_pk = alert.pk
    INNER JOIN alert_active_period ON alert_active_period.alert_pk = alert.pk
WHERE route.pk = ANY($1::bigint[])
    AND (
        alert_active_period.starts_at < $2
        OR alert_active_period.starts_at IS NULL
    )
    AND (
        alert_active_period.ends_at > $2
        OR alert_active_period.ends_at IS NULL
    )
ORDER BY alert.id ASC
`

type ListActiveAlertsForRoutesParams struct {
	RoutePks    []int64
	PresentTime pgtype.Timestamptz
}

type ListActiveAlertsForRoutesRow struct {
	RoutePk int64
	ID      string
	Cause   string
	Effect  string
}

// ListActiveAlertsForRoutes returns preview information about active alerts for the provided routes.
func (q *Queries) ListActiveAlertsForRoutes(ctx context.Context, arg ListActiveAlertsForRoutesParams) ([]ListActiveAlertsForRoutesRow, error) {
	rows, err := q.db.Query(ctx, listActiveAlertsForRoutes, arg.RoutePks, arg.PresentTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveAlertsForRoutesRow
	for rows.Next() {
		var i ListActiveAlertsForRoutesRow
		if err := rows.Scan(
			&i.RoutePk,
			&i.ID,
			&i.Cause,
			&i.Effect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAlertsForStops = `-- name: ListActiveAlertsForStops :many
SELECT stop.pk stop_pk, alert.pk, alert.id, alert.cause, alert.effect, alert_active_period.starts_at, alert_active_period.ends_at
FROM stop
    INNER JOIN alert_stop ON stop.pk = alert_stop.stop_pk
    INNER JOIN alert ON alert_stop.alert_pk = alert.pk
    INNER JOIN alert_active_period ON alert_active_period.alert_pk = alert.pk
WHERE stop.pk = ANY($1::bigint[])
    AND (
        alert_active_period.starts_at < $2
        OR alert_active_period.starts_at IS NULL
    )
    AND (
        alert_active_period.ends_at > $2
        OR alert_active_period.ends_at IS NULL
    )
ORDER BY alert.id ASC
`

type ListActiveAlertsForStopsParams struct {
	StopPks     []int64
	PresentTime pgtype.Timestamptz
}

type ListActiveAlertsForStopsRow struct {
	StopPk   int64
	Pk       int64
	ID       string
	Cause    string
	Effect   string
	StartsAt pgtype.Timestamptz
	EndsAt   pgtype.Timestamptz
}

func (q *Queries) ListActiveAlertsForStops(ctx context.Context, arg ListActiveAlertsForStopsParams) ([]ListActiveAlertsForStopsRow, error) {
	rows, err := q.db.Query(ctx, listActiveAlertsForStops, arg.StopPks, arg.PresentTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveAlertsForStopsRow
	for rows.Next() {
		var i ListActiveAlertsForStopsRow
		if err := rows.Scan(
			&i.StopPk,
			&i.Pk,
			&i.ID,
			&i.Cause,
			&i.Effect,
			&i.StartsAt,
			&i.EndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivePeriodsForAlerts = `-- name: ListActivePeriodsForAlerts :many
SELECT alert.pk, alert_active_period.starts_at, alert_active_period.ends_at
FROM alert
    INNER JOIN alert_active_period ON alert_active_period.alert_pk = alert.pk
WHERE alert.pk = ANY($1::bigint[])
`

type ListActivePeriodsForAlertsRow struct {
	Pk       int64
	StartsAt pgtype.Timestamptz
	EndsAt   pgtype.Timestamptz
}

func (q *Queries) ListActivePeriodsForAlerts(ctx context.Context, pks []int64) ([]ListActivePeriodsForAlertsRow, error) {
	rows, err := q.db.Query(ctx, listActivePeriodsForAlerts, pks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActivePeriodsForAlertsRow
	for rows.Next() {
		var i ListActivePeriodsForAlertsRow
		if err := rows.Scan(&i.Pk, &i.StartsAt, &i.EndsAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertPksAndHashes = `-- name: ListAlertPksAndHashes :many
SELECT id, pk, hash FROM alert
WHERE id = ANY($1::text[])
AND system_pk = $2
`

type ListAlertPksAndHashesParams struct {
	AlertIds []string
	SystemPk int64
}

type ListAlertPksAndHashesRow struct {
	ID   string
	Pk   int64
	Hash string
}

func (q *Queries) ListAlertPksAndHashes(ctx context.Context, arg ListAlertPksAndHashesParams) ([]ListAlertPksAndHashesRow, error) {
	rows, err := q.db.Query(ctx, listAlertPksAndHashes, arg.AlertIds, arg.SystemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlertPksAndHashesRow
	for rows.Next() {
		var i ListAlertPksAndHashesRow
		if err := rows.Scan(&i.ID, &i.Pk, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertsInSystem = `-- name: ListAlertsInSystem :many
SELECT pk, id, system_pk, cause, effect, header, description, url, hash, feed_pk FROM alert WHERE system_pk = $1 ORDER BY id ASC
`

func (q *Queries) ListAlertsInSystem(ctx context.Context, systemPk int64) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlertsInSystem, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.Cause,
			&i.Effect,
			&i.Header,
			&i.Description,
			&i.Url,
			&i.Hash,
			&i.FeedPk,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertsInSystemAndByIDs = `-- name: ListAlertsInSystemAndByIDs :many
SELECT pk, id, system_pk, cause, effect, header, description, url, hash, feed_pk FROM alert
    WHERE system_pk = $1
    AND id = ANY($2::text[])
ORDER BY id ASC
`

type ListAlertsInSystemAndByIDsParams struct {
	SystemPk int64
	Ids      []string
}

func (q *Queries) ListAlertsInSystemAndByIDs(ctx context.Context, arg ListAlertsInSystemAndByIDsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlertsInSystemAndByIDs, arg.SystemPk, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.Cause,
			&i.Effect,
			&i.Header,
			&i.Description,
			&i.Url,
			&i.Hash,
			&i.FeedPk,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertsWithActivePeriodsAndAllInformedEntities = `-- name: ListAlertsWithActivePeriodsAndAllInformedEntities :many
SELECT alert.id,
       alert.cause,
       alert.effect,
       alert.header,
       alert.description,
       alert.url,
       COALESCE(
               (ARRAY_AGG(
                DISTINCT tstzrange(alert_active_period.starts_at::timestamptz, alert_active_period.ends_at::timestamptz, '[)')
                ORDER BY tstzrange(alert_active_period.starts_at::timestamptz, alert_active_period.ends_at::timestamptz, '[)'))
                FILTER ( WHERE alert_active_period.starts_at IS NOT NULL OR alert_active_period.ends_at IS NOT NULL )),
               ARRAY []::tstzrange[])::tstzrange[] AS active_periods,
       COALESCE(
               (ARRAY_AGG(DISTINCT agency.id ORDER BY agency.id) FILTER (where agency.id is not null)),
               ARRAY []::text[])::text[]           AS agencies,
       COALESCE(
               (ARRAY_AGG(DISTINCT route.id ORDER BY route.id) FILTER (where route.id is not null)),
               ARRAY []::text[])::text[]           AS routes,
       COALESCE(
               (ARRAY_AGG(DISTINCT stop.id ORDER BY stop.id) FILTER (where stop.id is not null)),
               ARRAY []::text[])::text[]           AS stops,
       COALESCE(
               (ARRAY_AGG(DISTINCT trip.id ORDER BY trip.id) FILTER (where trip.id is not null)),
               ARRAY []::text[])::text[]           AS trips,
       COALESCE(
               (ARRAY_AGG(DISTINCT scheduled_trip.id ORDER BY scheduled_trip.id) FILTER (where scheduled_trip.id is not null)),
               ARRAY []::text[])::text[]           AS scheduled_trips,
       COALESCE(
               (ARRAY_AGG(DISTINCT route_type ORDER BY route_type) FILTER (where route_type is not null)),
               ARRAY []::text[])::text[]           AS route_types
FROM alert
         LEFT JOIN alert_active_period ON alert.pk = alert_active_period.alert_pk
         LEFT JOIN alert_agency ON alert.pk = alert_agency.alert_pk
         LEFT JOIN agency ON alert_agency.agency_pk = agency.pk
         LEFT JOIN alert_route ON alert.pk = alert_route.alert_pk
         LEFT JOIN route ON alert_route.route_pk = route.pk
         LEFT JOIN alert_stop ON alert.pk = alert_stop.alert_pk
         LEFT JOIN stop ON alert_stop.stop_pk = stop.pk
         LEFT JOIN alert_trip ON alert.pk = alert_trip.alert_pk
         LEFT JOIN trip ON alert_trip.trip_pk = trip.pk
         LEFT JOIN scheduled_trip ON alert_trip.scheduled_trip_pk = scheduled_trip.pk
         LEFT JOIN alert_route_type ON alert.pk = alert_route_type.alert_pk
WHERE alert.system_pk = $1
GROUP BY alert.id, alert.cause, alert.effect, alert.header, alert.description, alert.url
`

type ListAlertsWithActivePeriodsAndAllInformedEntitiesRow struct {
	ID             string
	Cause          string
	Effect         string
	Header         string
	Description    string
	Url            string
	ActivePeriods  []pgtype.Range[pgtype.Timestamptz]
	Agencies       []string
	Routes         []string
	Stops          []string
	Trips          []string
	ScheduledTrips []string
	RouteTypes     []string
}

func (q *Queries) ListAlertsWithActivePeriodsAndAllInformedEntities(ctx context.Context, systemPk int64) ([]ListAlertsWithActivePeriodsAndAllInformedEntitiesRow, error) {
	rows, err := q.db.Query(ctx, listAlertsWithActivePeriodsAndAllInformedEntities, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlertsWithActivePeriodsAndAllInformedEntitiesRow
	for rows.Next() {
		var i ListAlertsWithActivePeriodsAndAllInformedEntitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Cause,
			&i.Effect,
			&i.Header,
			&i.Description,
			&i.Url,
			&i.ActivePeriods,
			&i.Agencies,
			&i.Routes,
			&i.Stops,
			&i.Trips,
			&i.ScheduledTrips,
			&i.RouteTypes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
