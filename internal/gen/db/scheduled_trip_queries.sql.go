// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: scheduled_trip_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteScheduledTripFrequencies = `-- name: DeleteScheduledTripFrequencies :exec
DELETE FROM scheduled_trip_frequency
WHERE trip_pk = ANY($1::bigint[])
`

func (q *Queries) DeleteScheduledTripFrequencies(ctx context.Context, tripPks []int64) error {
	_, err := q.db.Exec(ctx, deleteScheduledTripFrequencies, tripPks)
	return err
}

const deleteScheduledTripShapes = `-- name: DeleteScheduledTripShapes :exec
DELETE FROM scheduled_trip_shape
WHERE trip_pk = ANY($1::bigint[])
`

func (q *Queries) DeleteScheduledTripShapes(ctx context.Context, tripPks []int64) error {
	_, err := q.db.Exec(ctx, deleteScheduledTripShapes, tripPks)
	return err
}

const deleteScheduledTripStopTimes = `-- name: DeleteScheduledTripStopTimes :exec
DELETE FROM scheduled_trip_stop_time
WHERE trip_pk = ANY($1::bigint[])
`

func (q *Queries) DeleteScheduledTripStopTimes(ctx context.Context, tripPks []int64) error {
	_, err := q.db.Exec(ctx, deleteScheduledTripStopTimes, tripPks)
	return err
}

const deleteStaleScheduledTrips = `-- name: DeleteStaleScheduledTrips :exec
DELETE FROM scheduled_trip
WHERE NOT scheduled_trip.pk = ANY($1::bigint[])
`

func (q *Queries) DeleteStaleScheduledTrips(ctx context.Context, updatedTripPks []int64) error {
	_, err := q.db.Exec(ctx, deleteStaleScheduledTrips, updatedTripPks)
	return err
}

const insertScheduledTrip = `-- name: InsertScheduledTrip :one
INSERT INTO scheduled_trip
    (id, route_pk, service_pk, direction_id, bikes_allowed, block_id, headsign, short_name, wheelchair_accessible)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING pk
`

type InsertScheduledTripParams struct {
	ID                   string
	RoutePk              int64
	ServicePk            int64
	DirectionID          pgtype.Bool
	BikesAllowed         pgtype.Bool
	BlockID              pgtype.Text
	Headsign             pgtype.Text
	ShortName            pgtype.Text
	WheelchairAccessible pgtype.Bool
}

func (q *Queries) InsertScheduledTrip(ctx context.Context, arg InsertScheduledTripParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertScheduledTrip,
		arg.ID,
		arg.RoutePk,
		arg.ServicePk,
		arg.DirectionID,
		arg.BikesAllowed,
		arg.BlockID,
		arg.Headsign,
		arg.ShortName,
		arg.WheelchairAccessible,
	)
	var pk int64
	err := row.Scan(&pk)
	return pk, err
}

const insertScheduledTripFrequency = `-- name: InsertScheduledTripFrequency :exec
INSERT INTO scheduled_trip_frequency
    (trip_pk, start_time, end_time, headway, frequency_based)
VALUES
    ($1, $2, $3, $4, $5)
`

type InsertScheduledTripFrequencyParams struct {
	TripPk         int64
	StartTime      int32
	EndTime        int32
	Headway        int32
	FrequencyBased bool
}

func (q *Queries) InsertScheduledTripFrequency(ctx context.Context, arg InsertScheduledTripFrequencyParams) error {
	_, err := q.db.Exec(ctx, insertScheduledTripFrequency,
		arg.TripPk,
		arg.StartTime,
		arg.EndTime,
		arg.Headway,
		arg.FrequencyBased,
	)
	return err
}

const insertScheduledTripShape = `-- name: InsertScheduledTripShape :exec
INSERT INTO scheduled_trip_shape
    (trip_pk, shape)
VALUES
    ($1, $2)
`

type InsertScheduledTripShapeParams struct {
	TripPk int64
	Shape  []byte
}

func (q *Queries) InsertScheduledTripShape(ctx context.Context, arg InsertScheduledTripShapeParams) error {
	_, err := q.db.Exec(ctx, insertScheduledTripShape, arg.TripPk, arg.Shape)
	return err
}

type InsertScheduledTripStopTimeParams struct {
	TripPk                int64
	StopPk                int64
	ArrivalTime           pgtype.Int4
	DepartureTime         pgtype.Int4
	StopSequence          int32
	ContinuousDropOff     string
	ContinuousPickup      string
	DropOffType           string
	ExactTimes            bool
	Headsign              pgtype.Text
	PickupType            string
	ShapeDistanceTraveled pgtype.Float8
}

const listScheduledTripFrequencies = `-- name: ListScheduledTripFrequencies :many
SELECT
    scheduled_trip_frequency.pk, scheduled_trip_frequency.trip_pk, scheduled_trip_frequency.headway, scheduled_trip_frequency.frequency_based, scheduled_trip_frequency.start_time, scheduled_trip_frequency.end_time,
    scheduled_trip.id trip_id
FROM scheduled_trip_frequency
INNER JOIN scheduled_trip ON scheduled_trip_frequency.trip_pk = scheduled_trip.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripFrequenciesRow struct {
	Pk             int64
	TripPk         int64
	Headway        int32
	FrequencyBased bool
	StartTime      int32
	EndTime        int32
	TripID         string
}

func (q *Queries) ListScheduledTripFrequencies(ctx context.Context, systemPk int64) ([]ListScheduledTripFrequenciesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTripFrequencies, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripFrequenciesRow
	for rows.Next() {
		var i ListScheduledTripFrequenciesRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.Headway,
			&i.FrequencyBased,
			&i.StartTime,
			&i.EndTime,
			&i.TripID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTripShapes = `-- name: ListScheduledTripShapes :many
SELECT
    scheduled_trip_shape.pk, scheduled_trip_shape.trip_pk, scheduled_trip_shape.shape,
    scheduled_trip.id trip_id
FROM scheduled_trip_shape
INNER JOIN scheduled_trip ON scheduled_trip_shape.trip_pk = scheduled_trip.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripShapesRow struct {
	Pk     int64
	TripPk int64
	Shape  []byte
	TripID string
}

func (q *Queries) ListScheduledTripShapes(ctx context.Context, systemPk int64) ([]ListScheduledTripShapesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTripShapes, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripShapesRow
	for rows.Next() {
		var i ListScheduledTripShapesRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.Shape,
			&i.TripID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTripStopTimes = `-- name: ListScheduledTripStopTimes :many
SELECT
    scheduled_trip_stop_time.pk, scheduled_trip_stop_time.trip_pk, scheduled_trip_stop_time.stop_pk, scheduled_trip_stop_time.stop_sequence, scheduled_trip_stop_time.continuous_drop_off, scheduled_trip_stop_time.continuous_pickup, scheduled_trip_stop_time.drop_off_type, scheduled_trip_stop_time.exact_times, scheduled_trip_stop_time.headsign, scheduled_trip_stop_time.pickup_type, scheduled_trip_stop_time.shape_distance_traveled, scheduled_trip_stop_time.arrival_time, scheduled_trip_stop_time.departure_time,
    scheduled_trip.id trip_id,
    stop.id stop_id
FROM scheduled_trip_stop_time
INNER JOIN scheduled_trip ON scheduled_trip_stop_time.trip_pk = scheduled_trip.pk
INNER JOIN stop ON scheduled_trip_stop_time.stop_pk = stop.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripStopTimesRow struct {
	Pk                    int64
	TripPk                int64
	StopPk                int64
	StopSequence          int32
	ContinuousDropOff     string
	ContinuousPickup      string
	DropOffType           string
	ExactTimes            bool
	Headsign              pgtype.Text
	PickupType            string
	ShapeDistanceTraveled pgtype.Float8
	ArrivalTime           pgtype.Int4
	DepartureTime         pgtype.Int4
	TripID                string
	StopID                string
}

func (q *Queries) ListScheduledTripStopTimes(ctx context.Context, systemPk int64) ([]ListScheduledTripStopTimesRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTripStopTimes, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripStopTimesRow
	for rows.Next() {
		var i ListScheduledTripStopTimesRow
		if err := rows.Scan(
			&i.Pk,
			&i.TripPk,
			&i.StopPk,
			&i.StopSequence,
			&i.ContinuousDropOff,
			&i.ContinuousPickup,
			&i.DropOffType,
			&i.ExactTimes,
			&i.Headsign,
			&i.PickupType,
			&i.ShapeDistanceTraveled,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.TripID,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTrips = `-- name: ListScheduledTrips :many
SELECT
    scheduled_trip.pk, scheduled_trip.id, scheduled_trip.route_pk, scheduled_trip.service_pk, scheduled_trip.direction_id, scheduled_trip.bikes_allowed, scheduled_trip.block_id, scheduled_trip.headsign, scheduled_trip.short_name, scheduled_trip.wheelchair_accessible,
    route.id route_id,
    scheduled_service.id service_id
FROM scheduled_trip
INNER JOIN route ON scheduled_trip.route_pk = route.pk
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE scheduled_service.system_pk = $1
`

type ListScheduledTripsRow struct {
	Pk                   int64
	ID                   string
	RoutePk              int64
	ServicePk            int64
	DirectionID          pgtype.Bool
	BikesAllowed         pgtype.Bool
	BlockID              pgtype.Text
	Headsign             pgtype.Text
	ShortName            pgtype.Text
	WheelchairAccessible pgtype.Bool
	RouteID              string
	ServiceID            string
}

func (q *Queries) ListScheduledTrips(ctx context.Context, systemPk int64) ([]ListScheduledTripsRow, error) {
	rows, err := q.db.Query(ctx, listScheduledTrips, systemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScheduledTripsRow
	for rows.Next() {
		var i ListScheduledTripsRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.RoutePk,
			&i.ServicePk,
			&i.DirectionID,
			&i.BikesAllowed,
			&i.BlockID,
			&i.Headsign,
			&i.ShortName,
			&i.WheelchairAccessible,
			&i.RouteID,
			&i.ServiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapScheduledTripIDToPkInSystem = `-- name: MapScheduledTripIDToPkInSystem :many
SELECT scheduled_trip.id, scheduled_trip.pk FROM scheduled_trip
INNER JOIN scheduled_service ON scheduled_trip.service_pk = scheduled_service.pk
WHERE
    system_pk = $1
    AND (
        NOT $2::bool
        OR scheduled_trip.id = ANY($3::text[])
    )
`

type MapScheduledTripIDToPkInSystemParams struct {
	SystemPk       int64
	FilterByTripID bool
	TripIds        []string
}

type MapScheduledTripIDToPkInSystemRow struct {
	ID string
	Pk int64
}

func (q *Queries) MapScheduledTripIDToPkInSystem(ctx context.Context, arg MapScheduledTripIDToPkInSystemParams) ([]MapScheduledTripIDToPkInSystemRow, error) {
	rows, err := q.db.Query(ctx, mapScheduledTripIDToPkInSystem, arg.SystemPk, arg.FilterByTripID, arg.TripIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapScheduledTripIDToPkInSystemRow
	for rows.Next() {
		var i MapScheduledTripIDToPkInSystemRow
		if err := rows.Scan(&i.ID, &i.Pk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledTrip = `-- name: UpdateScheduledTrip :exec
UPDATE scheduled_trip SET
    route_pk = $1,
    service_pk = $2,
    direction_id = $3,
    bikes_allowed = $4,
    block_id = $5,
    headsign = $6,
    short_name = $7,
    wheelchair_accessible = $8
WHERE pk = $9
`

type UpdateScheduledTripParams struct {
	RoutePk              int64
	ServicePk            int64
	DirectionID          pgtype.Bool
	BikesAllowed         pgtype.Bool
	BlockID              pgtype.Text
	Headsign             pgtype.Text
	ShortName            pgtype.Text
	WheelchairAccessible pgtype.Bool
	Pk                   int64
}

func (q *Queries) UpdateScheduledTrip(ctx context.Context, arg UpdateScheduledTripParams) error {
	_, err := q.db.Exec(ctx, updateScheduledTrip,
		arg.RoutePk,
		arg.ServicePk,
		arg.DirectionID,
		arg.BikesAllowed,
		arg.BlockID,
		arg.Headsign,
		arg.ShortName,
		arg.WheelchairAccessible,
		arg.Pk,
	)
	return err
}
