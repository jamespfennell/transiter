// Package dbwrappers contains methods that wrap the raw methods generated by sqlc and provide a nicer API.
package dbwrappers

import (
	"context"
	"database/sql"
	"log"
	"time"

	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/jamespfennell/transiter/internal/gen/db"
)

func MapStopIDToStationPk(ctx context.Context, querier db.Querier, systemPk int64) (map[string]int64, error) {
	rows, err := querier.MapStopIDToStationPk(ctx, systemPk)
	if err != nil {
		return nil, err
	}
	result := map[string]int64{}
	for _, row := range rows {
		result[row.StopID] = row.StationPk
	}
	return result, nil
}

func MapStopPkToStationPk(ctx context.Context, querier db.Querier, stopPks []int64) (map[int64]int64, error) {
	rows, err := querier.MapStopPkToStationPk(ctx, stopPks)
	if err != nil {
		return nil, err
	}
	result := map[int64]int64{}
	for _, row := range rows {
		result[row.StopPk] = row.StationPk
	}
	return result, nil
}

func MapStopIDToPkInSystem(ctx context.Context, querier db.Querier, systemPk int64, stopIDs []string) (map[string]int64, error) {
	rows, err := querier.MapStopsInSystem(ctx, db.MapStopsInSystemParams{
		SystemPk: systemPk,
		StopIds:  stopIDs,
	})
	if err != nil {
		return nil, err
	}
	result := map[string]int64{}
	for _, row := range rows {
		result[row.ID] = row.Pk
	}
	return result, nil
}

func MapRouteIDToPkInSystem(ctx context.Context, querier db.Querier, systemPk int64, routeIDs []string) (map[string]int64, error) {
	rows, err := querier.MapRoutesInSystem(ctx, db.MapRoutesInSystemParams{
		SystemPk: systemPk,
		RouteIds: routeIDs,
	})
	if err != nil {
		return nil, err
	}
	result := map[string]int64{}
	for _, row := range rows {
		result[row.ID] = row.Pk
	}
	return result, nil
}

type TripUID struct {
	ID      string
	RoutePk int64
}

type TripForUpdate struct {
	Pk          int64
	ID          string
	RoutePk     int64
	DirectionID sql.NullBool
	StopTimes   []StopTimeForUpdate
}

type StopTimeForUpdate struct {
	Pk           int64
	StopPk       int64
	StopSequence int32
	Past         bool
}

func ListTripsForUpdate(ctx context.Context, querier db.Querier, routePks []int64) (map[TripUID]*TripForUpdate, error) {
	tripRows, err := querier.ListTripsForUpdate(ctx, routePks)
	if err != nil {
		return nil, err
	}
	result := map[TripUID]*TripForUpdate{}
	tripPkToUID := map[int64]TripUID{}
	var tripPks []int64
	for _, tripRow := range tripRows {
		uid := TripUID{RoutePk: tripRow.RoutePk, ID: tripRow.ID}
		tripPks = append(tripPks, tripRow.Pk)
		tripPkToUID[tripRow.Pk] = uid
		result[uid] = &TripForUpdate{
			Pk:          tripRow.Pk,
			ID:          tripRow.ID,
			RoutePk:     tripRow.RoutePk,
			DirectionID: tripRow.DirectionID,
		}
	}
	stopTimeRows, err := querier.ListTripStopTimesForUpdate(ctx, tripPks)
	if err != nil {
		return nil, err
	}
	for _, stopTimeRow := range stopTimeRows {
		uid := tripPkToUID[stopTimeRow.TripPk]
		tripForUpdate := result[uid]
		tripForUpdate.StopTimes = append(tripForUpdate.StopTimes, StopTimeForUpdate{
			Pk:           stopTimeRow.Pk,
			StopPk:       stopTimeRow.StopPk,
			StopSequence: stopTimeRow.StopSequence,
			Past:         stopTimeRow.Past,
		})
		result[uid] = tripForUpdate
	}
	return result, nil
}

func Ping(ctx context.Context, pool *pgxpool.Pool, numRetries int, waitBetweenPings time.Duration) error {
	var err error
	for i := 0; i < numRetries; i++ {
		err = pool.Ping(ctx)
		if err == nil {
			log.Printf("Database ping successful")
			break
		}
		log.Printf("Failed to ping the database: %s\n", err)
		if i != numRetries-1 {
			log.Printf("Will try to ping again in %s", waitBetweenPings)
			time.Sleep(waitBetweenPings)
		}
	}
	return err
}
